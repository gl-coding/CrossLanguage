source:https://www.zhihu.com/question/41609070/answer/191965937

RPC(Remote Procedure Call)，远程过程调用，大部分的RPC框架都遵循如下三个开发步骤：

1. 定义一个接口说明文件：描述了对象(结构体)、对象成员、接口方法等一系列信息；
2. 通过RPC框架所提供的编译器，将接口说明文件编译成具体的语言文件；
3. 在客户端和服务器端分别引入RPC编译器所生成的文件，即可像调用本地方法一样调用服务端代码；

通信过程包括以下几个步骤：

1、客户过程以正常方式调用客户桩（client stub，一段代码）；
2、客户桩生成一个消息，然后调用本地操作系统；
3、客户端操作系统将消息发送给远程操作系统；
4、远程操作系统将消息交给服务器桩（server stub，一段代码）；
5、服务器桩将参数提取出来，然后调用服务器过程；
6、服务器执行要求的操作，操作完成后将结果返回给服务器桩；
7、服务器桩将结果打包成一个消息，然后调用本地操作系统；
8、服务器操作系统将含有结果的消息发送回客户端操作系统；
9、客户端操作系统将消息交给客户桩；
10、客户桩将结果从从消息中提取出来，返回给调用它的客户过程；

所有这些步骤的效果是，将客户过程对客户桩发出的本地调用转换成对服务器过程的本地调用，而客户端和服务器都不会意识到有中间步骤的存在。

这个时候，你可能会想，既然是调用另一台机器的服务，使用 RESTful API 也可以实现啊，为什么要选择 RPC 呢？我们可以从两个方面对比：

资源粒度。RPC 就像本地方法调用，RESTful API 每一次添加接口都可能需要额外地组织开放接口的数据，这相当于在应用视图中再写了一次方法调用，而且它还需要维护开发接口的资源粒度、权限等；
流量消耗。RESTful API 在应用层使用 HTTP 协议，哪怕使用轻型、高效、传输效率高的 JSON 也会消耗较大的流量，而 RPC 传输既可以使用 TCP 也可以使用 UDP，而且协议一般使用二制度编码，大大降低了数据的大小，减少流量消耗。

HTTP是一种应用层网络协议，RPC可以采用tcp自定义协议，也可以通过HTTP协议来传输，thrift，grpc，xml-rpc，json-rpc都是通过HTTP传输的。HTTP既支持长连接，也支持短连接。

rpc是远端过程调用，其调用协议通常包含传输协议和序列化协议。
    传输协议包含: 如著名的 [gRPC](grpc / grpc.io) 使用的 http2 协议，也有如dubbo一类的自定义报文的tcp协议。i
    序列化协议包含: 如基于文本编码的xml json，也有二进制编码的protobuf hessian等。
    服务封装: 把对服务器的调用抽象为过程调用，随着框架代码自动生成、序列化反序列化，

报文上的区别：
 http 使用的 tcp 协议，和rpc自定义的 tcp 协议在报文上的区别。

使用http:
    首先要否认一点 http 协议相较于自定义tcp报文协议，增加的开销在于连接的建立与断开。
        http协议是支持连接池复用的，也就是建立一定数量的连接不断开，并不会频繁的创建和销毁连接。支持长连接和短链接
    二一要说的是http也可以使用protobuf这种二进制编码协议对内容进行编码，因此二者最大的区别还是在传输协议上。
        通用定义的http1.1协议的tcp报文包含太多废信息，一个POST协议的格式大致如下

HTTP/1.0 200 OK 
Content-Type: text/plain
Content-Length: 137582
Expires: Thu, 05 Dec 1997 16:00:00 GMT
Last-Modified: Wed, 5 August 1996 15:55:28 GMT
Server: Apache 0.84

<html>
  <body>Hello World</body>
</html>

即使编码协议也就是body是使用二进制编码协议
报文元数据也就是header头的键值对却用了文本编码，非常占字节数。
如上图所使用的报文中有效字节数仅仅占约 30%，也就是70%的时间用于传输元数据废编码。

当然实际情况下报文内容可能会比这个长，但是报头所占的比例也是非常可观的。

使用Tcp
报头占用的字节数也就只有16个byte，极大地精简了传输内容。
这也就是为什么后端进程间通常会采用自定义tcp协议的rpc来进行通信的原因。

所以为什么要用rpc调用？

性能：
这么来说吧http容器的性能测试单位通常是kqps，自定义tpc协议则通常是以10kqps到100kqps为基准
所谓的效率优势是针对http1.1协议来讲的，http2.0协议已经优化编码效率问题，像grpc这种rpc库使用的就是http2.0协议。

服务：
简单来说成熟的rpc库相对http容器，更多的是封装了“服务发现”，"负载均衡"，“熔断降级”一类面向服务的高级特性。
因为良好的rpc调用是面向服务的封装，针对服务的可用性和效率等都做了优化。
可以这么理解，rpc框架是面向服务的更高级的封装。如果把一个http servlet容器上封装一层服务发现和函数代理调用，那它就已经可以做一个rpc框架了。

单纯使用http调用则缺少了这些特性。
